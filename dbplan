#!/bin/bash

# ==============================================================================
#
#          dbplan - Convert PROJECT/DEVPLAN phases into GitHub feature issues
#
# ==============================================================================

set -euo pipefail

# ----------------------------- Configuration ---------------------------------
COLOR_RESET='\e[0m'
COLOR_RED='\e[0;31m'
COLOR_GREEN='\e[0;32m'
COLOR_YELLOW='\e[0;33m'
COLOR_BLUE='\e[0;34m'
COLOR_CYAN='\e[0;36m'

ICON_INFO="ℹ️"
ICON_SUCCESS="✅"
ICON_WARNING="⚠️"
ICON_ERROR="❌"
ICON_GH="🐙"

DEFAULT_LABEL="feature"

# ------------------------------ Utilities ------------------------------------
print_msg() { # color icon message
  local color="$1"; shift
  local icon="$1"; shift
  printf "%b %s%b\n" "${color}${icon}" "$*" "${COLOR_RESET}"
}

die() {
  print_msg "$COLOR_RED" "$ICON_ERROR" "$*"
  exit 1
}

command_exists() { command -v "$1" >/dev/null 2>&1; }

hash_phase_id() { # input: file path + phase title -> short stable id
  local input="$1"
  if command_exists shasum; then
    printf "%s" "$input" | shasum -a 256 | cut -c1-16
  elif command_exists sha256sum; then
    printf "%s" "$input" | sha256sum | cut -c1-16
  else
    # poor-man fallback
    printf "%s" "$input" | md5 2>/dev/null | cut -c1-16 || true
  fi
}

ensure_label_exists() {
  local repo="$1"; shift
  local label_name="$1"
  # Check existing labels
  if ! gh label list --repo "$repo" --json name | grep -q "\"${label_name}\""; then
    print_msg "$COLOR_YELLOW" "$ICON_INFO" "Creating missing label '${label_name}' in ${repo}"
    # Default blue color; description generic
    gh label create "$label_name" --repo "$repo" --color "1D76DB" --description "Feature work" >/dev/null 2>&1 || true
  fi
}

get_repo() {
  # Uses gh to infer repo from current git remote
  gh repo view --json nameWithOwner -q .nameWithOwner 2>/dev/null || true
}

usage() {
  cat <<EOF
Usage: dbplan [--file PATH] [--label NAME] [--dry-run] [--update-closed] [--repo OWNER/NAME] [--verbose] [--branch [ISSUE_NUMBER]] [--pr [ISSUE_NUMBER]] [--merge] [--merge-method METHOD] [--base BRANCH] [--draft]

Parses a dev plan section from PROJECT.md/DEVPLAN.md and creates/updates GitHub issues (one per phase).

Options:
  --file PATH          Path to plan file. Defaults to DEVPLAN.md, then PROJECT.md
  --label NAME         Label to apply to created issues (default: ${DEFAULT_LABEL})
  --repo OWNER/NAME    Target GitHub repo. Defaults to current directory's repo via gh
  --dry-run            Print actions without calling GitHub
  --update-closed      Allow updates to closed issues (default: skip closed)
  --verbose            Verbose logging
  --branch [NUM]       Interactive branch mode. Lists feature issues to choose from and creates a local+remote branch. Optionally pass an issue number to skip prompting.
  --pr [NUM]           Create a pull request from the current branch. If NUM omitted, infer from branch name (issue-<NUM>) or prompt to select. PR body includes "Closes #NUM".
  --merge              After creating the PR, merge it and delete the branch.
  --merge-method M     One of: squash (default), merge, rebase.
  --base BRANCH        Base branch for the PR (default: main).
  --draft              Create PR as a draft.
  --help               Show this help

The plan section must be enclosed by markers:
  <!-- devplan:start -->
  ... phases & tasks ...
  <!-- devplan:end -->

Phase heading format:
  ## Phase: Title Here
Tasks (markdown checkboxes):
  - [ ] Task description
  - [x] Optional completed task
EOF
}

# --------------------------- Argument parsing --------------------------------
PLAN_FILE=""
LABEL_NAME="${DEFAULT_LABEL}"
REPO_OVERRIDE=""
DRY_RUN=false
UPDATE_CLOSED=false
VERBOSE=false
BRANCH_MODE=false
BRANCH_ISSUE_NUMBER=""
PR_MODE=false
PR_ISSUE_NUMBER=""
PR_MERGE=false
PR_MERGE_METHOD="squash"
PR_BASE_BRANCH="main"
PR_DRAFT=false

while [[ $# -gt 0 ]]; do
  case "$1" in
    --file) PLAN_FILE="$2"; shift 2 ;;
    --label) LABEL_NAME="$2"; shift 2 ;;
    --repo) REPO_OVERRIDE="$2"; shift 2 ;;
    --dry-run) DRY_RUN=true; shift ;;
    --update-closed) UPDATE_CLOSED=true; shift ;;
    --verbose) VERBOSE=true; shift ;;
    --branch) BRANCH_MODE=true; if [[ ${2-:-} != --* && -n ${2-} ]]; then BRANCH_ISSUE_NUMBER="$2"; shift 2; else shift; fi ;;
    --pr) PR_MODE=true; if [[ ${2-:-} != --* && -n ${2-} ]]; then PR_ISSUE_NUMBER="$2"; shift 2; else shift; fi ;;
    --merge) PR_MERGE=true; shift ;;
    --merge-method) PR_MERGE_METHOD="$2"; shift 2 ;;
    --base) PR_BASE_BRANCH="$2"; shift 2 ;;
    --draft) PR_DRAFT=true; shift ;;
    --help|-h) usage; exit 0 ;;
    *) die "Unknown argument: $1" ;;
  esac
done

# ------------------------------ Preconditions --------------------------------
command_exists gh || die "GitHub CLI (gh) is required"
command_exists git || die "git is required"
command_exists jq || die "jq is required"
git rev-parse --is-inside-work-tree >/dev/null 2>&1 || die "Not inside a git repository"

if [[ "$BRANCH_MODE" != true ]]; then
  if [[ -z "${PLAN_FILE}" ]]; then
    if [[ -f "DEVPLAN.md" ]]; then PLAN_FILE="DEVPLAN.md"; 
    elif [[ -f "PROJECT.md" ]]; then PLAN_FILE="PROJECT.md"; 
    else
      die "No plan file found. Provide --file or add DEVPLAN.md/PROJECT.md"
    fi
  fi
  [[ -f "${PLAN_FILE}" ]] || die "Plan file not found: ${PLAN_FILE}"
fi

REPO_NAME="${REPO_OVERRIDE}"
if [[ -z "${REPO_NAME}" ]]; then
  REPO_NAME=$(get_repo)
  [[ -n "${REPO_NAME}" ]] || die "Unable to detect repo. Ensure you're in a GitHub repo (gh auth + git remote). Or pass --repo"
fi

${VERBOSE} && print_msg "$COLOR_CYAN" "$ICON_GH" "Repo: ${REPO_NAME}"
${VERBOSE} && print_msg "$COLOR_CYAN" "$ICON_INFO" "Plan file: ${PLAN_FILE}"

# Ensure label exists (best-effort) when not in branch mode (not required but harmless)
ensure_label_exists "$REPO_NAME" "$LABEL_NAME"

# ------------------------------ Parse section --------------------------------
if [[ "$BRANCH_MODE" != true ]]; then
  PLAN_SECTION=$(awk '/<!--[[:space:]]*devplan:start[[:space:]]*-->/{flag=1;next} /<!--[[:space:]]*devplan:end[[:space:]]*-->/{flag=0} flag' "$PLAN_FILE")
  if [[ -z "$PLAN_SECTION" ]]; then
    die "No devplan section found between markers in ${PLAN_FILE}"
  fi
fi

# --------------------------- Extract phases/tasks -----------------------------
TMP_DIR=$(mktemp -d 2>/dev/null || mktemp -d -t dbplan)
trap 'rm -rf "$TMP_DIR"' EXIT

if [[ "$BRANCH_MODE" != true ]]; then
  current_phase_title=""
  current_tasks_file=""
  declare -a PHASE_TITLES=()
  declare -a PHASE_TASK_FILES=()

  while IFS= read -r line; do
    if [[ "$line" =~ ^\#\#[[:space:]]*Phase:[[:space:]]*(.+)$ ]]; then
      # flush previous phase if any
      if [[ -n "$current_phase_title" ]]; then
        PHASE_TITLES+=("$current_phase_title")
        PHASE_TASK_FILES+=("$current_tasks_file")
      fi
      current_phase_title="${BASH_REMATCH[1]}"
      current_tasks_file="${TMP_DIR}/tasks_$(printf "%s" "$current_phase_title" | tr ' ' '_' | tr -cd '[:alnum:]_').md"
      : > "$current_tasks_file"
    else
      # capture checkbox lines under an active phase
      if [[ -n "$current_phase_title" ]]; then
        if [[ "$line" =~ ^[[:space:]]*-[[:space:]]*\[[xX[:space:]]\][[:space:]].*$ ]]; then
          printf "%s\n" "$line" >> "$current_tasks_file"
        fi
      fi
    fi
  done <<< "$PLAN_SECTION"

  # flush last phase
  if [[ -n "$current_phase_title" ]]; then
    PHASE_TITLES+=("$current_phase_title")
    PHASE_TASK_FILES+=("$current_tasks_file")
  fi

  [[ ${#PHASE_TITLES[@]} -gt 0 ]] || die "No phases found. Ensure lines like: '## Phase: Title' and checkbox tasks under them."
fi

# ------------------------------- Branch mode ---------------------------------
slugify() {
  local s="$1"
  s=$(printf "%s" "$s" | tr '[:upper:]' '[:lower:]')
  s=$(printf "%s" "$s" | sed -E 's/[^a-z0-9]+/-/g')
  s=$(printf "%s" "$s" | sed -E 's/^-+|-+$//g')
  printf "%s" "$s"
}

if [[ "$BRANCH_MODE" == true ]]; then
  ${VERBOSE} && print_msg "$COLOR_CYAN" "$ICON_INFO" "Branch mode enabled"
  # Fetch issues with the label and starting with Feature:
  issues_json=$(gh issue list --repo "$REPO_NAME" --label "$LABEL_NAME" --state open --limit 200 --json number,title)
  count=$(echo "$issues_json" | jq '[ .[] | select(.title|startswith("Feature: ")) ] | length')
  if [[ "$count" -eq 0 ]]; then
    die "No open feature issues found with label '${LABEL_NAME}'"
  fi

  if [[ -n "$BRANCH_ISSUE_NUMBER" ]]; then
    sel=$(echo "$issues_json" | jq --arg n "$BRANCH_ISSUE_NUMBER" '[ .[] | select((.title|startswith("Feature: ")) and (.number|tostring==$n)) ] | .[0]')
    if [[ "$sel" == "null" || -z "$sel" ]]; then
      die "Issue #$BRANCH_ISSUE_NUMBER not found among open feature issues"
    fi
  else
    # Print numbered menu
    echo "Select a feature issue to branch from:"
    menu=$(echo "$issues_json" | jq -r '[ .[] | select(.title|startswith("Feature: ")) ] | to_entries | .[] | "\(.key+1)) #\(.value.number) - \(.value.title)"')
    printf "%s\n" "$menu"
    printf "Enter selection (1-%s) or issue number: " "$count"
    read -r choice
    if [[ "$choice" =~ ^[0-9]+$ ]]; then
      # Determine if choice is menu index or issue number
      sel=$(echo "$issues_json" | jq --argjson idx "$((choice-1))" '[ .[] | select(.title|startswith("Feature: ")) ] | .[$idx]')
      if [[ "$sel" == "null" || -z "$sel" ]]; then
        # try as issue number
        sel=$(echo "$issues_json" | jq --arg n "$choice" '[ .[] | select((.title|startswith("Feature: ")) and (.number|tostring==$n)) ] | .[0]')
        [[ "$sel" != "null" && -n "$sel" ]] || die "Invalid selection"
      fi
    else
      die "Invalid selection"
    fi
  fi

  issue_number=$(echo "$sel" | jq -r '.number')
  issue_title=$(echo "$sel" | jq -r '.title')
  slug=$(slugify "$issue_title")
  branch_name="feature/issue-${issue_number}-${slug}"

  print_msg "$COLOR_CYAN" "$ICON_INFO" "Creating branch: ${branch_name}"
  if git rev-parse --verify "$branch_name" >/dev/null 2>&1; then
    print_msg "$COLOR_YELLOW" "$ICON_WARNING" "Branch exists locally. Checking out."
    git checkout "$branch_name"
  else
    git checkout -b "$branch_name"
  fi

  # Create remote if missing
  if ! git ls-remote --exit-code --heads origin "$branch_name" >/dev/null 2>&1; then
    git push -u origin "$branch_name"
  else
    print_msg "$COLOR_YELLOW" "$ICON_WARNING" "Remote branch already exists; setting upstream"
    git branch --set-upstream-to "origin/${branch_name}" "$branch_name" || true
  fi

  print_msg "$COLOR_GREEN" "$ICON_SUCCESS" "Switched to branch ${branch_name}. Start developing!"
  exit 0
fi

# ------------------------------- PR mode -------------------------------------

infer_issue_from_branch() {
  local branch="$1"
  if [[ "$branch" =~ issue-([0-9]+) ]]; then
    echo "${BASH_REMATCH[1]}"
  else
    echo ""
  fi
}

if [[ "$PR_MODE" == true ]]; then
  ${VERBOSE} && print_msg "$COLOR_CYAN" "$ICON_INFO" "PR mode enabled"
  current_branch=$(git symbolic-ref --short HEAD)

  # Try inferring issue number from the current branch name (feature/issue-<N>-...)
  if [[ -z "$PR_ISSUE_NUMBER" ]]; then
    PR_ISSUE_NUMBER=$(infer_issue_from_branch "$current_branch")
  fi

  # If still empty, allow interactive select among open feature issues
  if [[ -z "$PR_ISSUE_NUMBER" ]]; then
    issues_json=$(gh issue list --repo "$REPO_NAME" --label "$LABEL_NAME" --state open --limit 200 --json number,title)
    count=$(echo "$issues_json" | jq '[ .[] | select(.title|startswith("Feature: ")) ] | length')
    if [[ "$count" -eq 0 ]]; then
      die "No open feature issues found to create a PR against."
    fi
    echo "Select an issue to associate with the PR:"
    menu=$(echo "$issues_json" | jq -r '[ .[] | select(.title|startswith("Feature: ")) ] | to_entries | .[] | "\(.key+1)) #\(.value.number) - \(.value.title)"')
    printf "%s\n" "$menu"
    printf "Enter selection (1-%s) or issue number: " "$count"
    read -r choice
    if [[ "$choice" =~ ^[0-9]+$ ]]; then
      sel=$(echo "$issues_json" | jq --argjson idx "$((choice-1))" '[ .[] | select(.title|startswith("Feature: ")) ] | .[$idx]')
      if [[ "$sel" == "null" || -z "$sel" ]]; then
        sel=$(echo "$issues_json" | jq --arg n "$choice" '[ .[] | select((.title|startswith("Feature: ")) and (.number|tostring==$n)) ] | .[0]')
        [[ "$sel" != "null" && -n "$sel" ]] || die "Invalid selection"
      fi
      PR_ISSUE_NUMBER=$(echo "$sel" | jq -r '.number')
    else
      die "Invalid selection"
    fi
  fi

  # Ensure we are not on base branch now
  if [[ "$current_branch" == "$PR_BASE_BRANCH" ]]; then
    die "Current branch equals base (${PR_BASE_BRANCH}). Checkout a feature branch first or use --branch."
  fi

  # Ensure branch is pushed
  if ! git rev-parse --verify "@{u}" >/dev/null 2>&1; then
    print_msg "$COLOR_CYAN" "$ICON_INFO" "Pushing current branch and setting upstream..."
    git push -u origin "$current_branch"
  fi

  # Title/body for PR
  issue_title=$(gh issue view "$PR_ISSUE_NUMBER" --repo "$REPO_NAME" --json title -q .title 2>/dev/null || echo "Feature #$PR_ISSUE_NUMBER")
  pr_title="$issue_title"
  pr_body="Closes #${PR_ISSUE_NUMBER}"

  create_args=(--repo "$REPO_NAME" --base "$PR_BASE_BRANCH" --title "$pr_title" --body "$pr_body")
  $PR_DRAFT && create_args+=(--draft)

  print_msg "$COLOR_CYAN" "$ICON_INFO" "Creating PR to ${PR_BASE_BRANCH} for #${PR_ISSUE_NUMBER}..."
  if gh pr create "${create_args[@]}"; then
    print_msg "$COLOR_GREEN" "$ICON_SUCCESS" "PR created."
  else
    die "Failed to create PR."
  fi

  if $PR_MERGE; then
    # Determine PR number for current branch
    pr_num=$(gh pr view --repo "$REPO_NAME" --head "$current_branch" --json number -q .number 2>/dev/null || true)
    if [[ -z "$pr_num" || "$pr_num" == "null" ]]; then
      pr_num=$(gh pr list --repo "$REPO_NAME" --head "$current_branch" --state open --json number -q '.[0].number' 2>/dev/null || true)
    fi
    [[ -n "$pr_num" ]] || die "Unable to determine PR number for merge."
    method_flag="--squash"
    case "$PR_MERGE_METHOD" in
      squash) method_flag="--squash" ;;
      merge) method_flag="--merge" ;;
      rebase) method_flag="--rebase" ;;
      *) print_msg "$COLOR_YELLOW" "$ICON_WARNING" "Unknown merge method '${PR_MERGE_METHOD}', defaulting to squash." ;;
    esac
    print_msg "$COLOR_CYAN" "$ICON_INFO" "Merging PR #${pr_num} with method ${PR_MERGE_METHOD}..."
    if gh pr merge "$pr_num" "$method_flag" --delete-branch --repo "$REPO_NAME"; then
      print_msg "$COLOR_GREEN" "$ICON_SUCCESS" "PR merged and branch deleted."
      git checkout "$PR_BASE_BRANCH" >/dev/null 2>&1 || true
      git pull --ff-only || true
    else
      die "Failed to merge PR."
    fi
  fi

  exit 0
fi

# ------------------------------- Issue sync ----------------------------------
create_or_update_issue() {
  local repo="$1"; shift
  local phase_title="$1"; shift
  local tasks_file="$1"; shift

  local phase_id
  phase_id=$(hash_phase_id "${PLAN_FILE}:${phase_title}")
  local issue_title="Feature: ${phase_title}"

  # Build body
  local body_file
  body_file="${TMP_DIR}/body_$(printf "%s" "$phase_title" | tr ' ' '_' | tr -cd '[:alnum:]_').md"
  {
    printf "## Phase: %s\n\n" "$phase_title"
    printf "### Tasks\n"
    if [[ -s "$tasks_file" ]]; then
      cat "$tasks_file"
    else
      printf "- [ ] (no tasks listed)\n"
    fi
    printf "\n<!-- plan-source: %s; phase-id: %s -->\n" "$PLAN_FILE" "$phase_id"
  } > "$body_file"

  ${VERBOSE} && print_msg "$COLOR_BLUE" "$ICON_INFO" "Searching for existing issue by marker: ${phase_id}"

  # Search by hidden marker in body
  local existing_json
  existing_json=$(gh issue list --repo "$repo" --limit 200 --search "in:body \"${phase_id}\"" --json number,title,state 2>/dev/null || true)

  local issue_number=""
  if echo "$existing_json" | grep -q '"number"'; then
    issue_number=$(echo "$existing_json" | jq -r '.[0].number' 2>/dev/null || true)
  fi

  # Fallback: search by title if marker not found
  if [[ -z "$issue_number" ]]; then
    existing_json=$(gh issue list --repo "$repo" --limit 200 --search "in:title \"${issue_title}\"" --json number,title,state 2>/dev/null || true)
    if echo "$existing_json" | grep -q '"number"'; then
      issue_number=$(echo "$existing_json" | jq -r '.[0].number' 2>/dev/null || true)
    fi
  fi

  if [[ -z "$issue_number" ]]; then
    if $DRY_RUN; then
      print_msg "$COLOR_GREEN" "$ICON_SUCCESS" "[dry-run] Would create issue: '${issue_title}' with label '${LABEL_NAME}'"
    else
      print_msg "$COLOR_GREEN" "$ICON_SUCCESS" "Creating issue: ${issue_title}"
      gh issue create --repo "$repo" --title "$issue_title" --label "$LABEL_NAME" --body-file "$body_file" >/dev/null
    fi
    return 0
  fi

  # Issue exists; maybe update
  local state
  state=$(echo "$existing_json" | jq -r '.[0].state' 2>/dev/null || echo "OPEN")
  if [[ "$state" != "OPEN" && "$UPDATE_CLOSED" != true ]]; then
    print_msg "$COLOR_YELLOW" "$ICON_WARNING" "Skipping closed issue #${issue_number} (${issue_title}). Use --update-closed to modify."
    return 0
  fi

  # Compare body contents
  local current_body
  current_body=$(gh issue view "$issue_number" --repo "$repo" --json body -q .body)

  # Normalize whitespace for comparison
  local new_body_norm cur_body_norm
  new_body_norm=$(tr -d '\r' < "$body_file")
  cur_body_norm=$(printf "%s" "$current_body" | tr -d '\r')

  if [[ "$new_body_norm" == "$cur_body_norm" ]]; then
    ${VERBOSE} && print_msg "$COLOR_GREEN" "$ICON_SUCCESS" "Issue #${issue_number} is up to date."
    return 0
  fi

  if $DRY_RUN; then
    print_msg "$COLOR_GREEN" "$ICON_SUCCESS" "[dry-run] Would update issue #${issue_number}: '${issue_title}'"
  else
    print_msg "$COLOR_GREEN" "$ICON_SUCCESS" "Updating issue #${issue_number}: ${issue_title}"
    gh issue edit "$issue_number" --repo "$repo" --body-file "$body_file" >/dev/null
    # Ensure label present
    gh issue edit "$issue_number" --repo "$repo" --add-label "$LABEL_NAME" >/dev/null 2>&1 || true
  fi
}

# Iterate phases
for idx in "${!PHASE_TITLES[@]}"; do
  create_or_update_issue "$REPO_NAME" "${PHASE_TITLES[$idx]}" "${PHASE_TASK_FILES[$idx]}"
done

print_msg "$COLOR_GREEN" "$ICON_SUCCESS" "dbplan completed. Phases processed: ${#PHASE_TITLES[@]}"



#!/bin/bash

# ==============================================================================
#
#          dbbuild - A Sophisticated Build & Release Automation Script
#
# ==============================================================================
#
#  SYNOPSIS
#  ./dbbuild [FLAGS]
#
#  DESCRIPTION
#  This script automates the entire release workflow: versioning, building,
#  Git operations (commit, tag, push), and GitHub integration (PRs, releases).
#  It includes safeguards like secret scanning and .gitignore management.
#
# ==============================================================================


# --- ⚙️ CONFIGURATION ⚙️ ---

# Defines the color palette used for printing messages.
COLOR_RESET='\e[0m'
COLOR_RED='\e[0;31m'
COLOR_GREEN='\e[0;32m'
COLOR_YELLOW='\e[0;33m'
COLOR_BLUE='\e[0;34m'
COLOR_PURPLE='\e[0;35m'
COLOR_CYAN='\e[0;36m'

# Defines the icons (emojis) used for different message types.
ICON_ROCKET="🚀"
ICON_INFO="ℹ️"
ICON_SUCCESS="✅"
ICON_WARNING="⚠️"
ICON_ERROR="❌"
ICON_GIT="🐙"
ICON_TAG="🏷️"
ICON_BUILD="📦"
ICON_PULL_REQUEST="🔀"
ICON_RELEASE="🎉"
ICON_QUESTION="❓"
ICON_SHIELD="🛡️"
ICON_CF="☁️"


# --- 헬퍼 함수 (HELPER FUNCTIONS) ---

print_message() {
  local color="$1"
  local icon="$2"
  local message="$3"
  printf "${color}%s %s${COLOR_RESET}\n" "$icon" "$message"
}

print_text() {
  printf "%s\n" "$1"
}

prompt_yes_no() {
  local message=$1
  local reply
  printf "${COLOR_CYAN}%s %s (y/n) ${COLOR_RESET}" "$ICON_QUESTION" "$message"
  read -n 1 -r reply
  printf "\n"
  if [[ $reply =~ ^[Yy]$ ]]; then
    return 0
  else
    return 1
  fi
}

command_exists() {
  command -v "$1" >/dev/null 2>&1
}


# --- 📖 HELP FUNCTION 📖 ---

show_help() {
  print_message "$COLOR_CYAN" "$ICON_ROCKET" "dbbuild - Build & Release Automation"
  print_text ""
  print_message "$COLOR_PURPLE" "" "USAGE:"
  print_text "  ./dbbuild [FLAGS]"
  print_text ""
  print_message "$COLOR_PURPLE" "" "FLAGS:"
  printf "${COLOR_GREEN}  --help               %s${COLOR_RESET}\n" "Show this help message."
  printf "${COLOR_GREEN}  --patch              %s${COLOR_RESET}\n" "Set version bump to patch."
  printf "${COLOR_GREEN}  --minor              %s${COLOR_RESET}\n" "Set version bump to minor."
  printf "${COLOR_GREEN}  --major              %s${COLOR_RESET}\n" "Set version bump to major."
  printf "${COLOR_GREEN}  --keep-version       %s${COLOR_RESET}\n" "Keep the current version for a re-release."
  printf "${COLOR_GREEN}  --set-version <VER>  %s${COLOR_RESET}\n" "Set a specific version number (e.g., 1.2.3-rc1)."
  printf "${COLOR_GREEN}  --no-build           %s${COLOR_RESET}\n" "Skip the build step entirely."
  printf "${COLOR_GREEN}  --no-jar             %s${COLOR_RESET}\n" "Do not attach a JAR to the GitHub release."
  printf "${COLOR_GREEN}  -y, --yes            %s${COLOR_RESET}\n" "Automatically answer 'yes' to all prompts."
  print_text ""
}


# --- 🚩 ARGUMENT PARSING 🚩 ---

BUMP_TYPE=""
SET_VERSION=""
AUTO_YES=false
NO_BUILD=false
NO_JAR=false

while [[ $# -gt 0 ]]; do
  key="$1"
  case $key in
    --help) show_help; exit 0 ;; 
    --patch) BUMP_TYPE="patch"; shift ;; 
    --minor) BUMP_TYPE="minor"; shift ;; 
    --major) BUMP_TYPE="major"; shift ;; 
    --keep-version) BUMP_TYPE="keep"; shift ;; 
    --set-version) SET_VERSION="$2"; BUMP_TYPE="custom"; shift; shift ;; 
    --no-build) NO_BUILD=true; shift ;; 
    --no-jar) NO_JAR=true; shift ;; 
    -y|--yes) AUTO_YES=true; shift ;; 
    *) print_message "$COLOR_RED" "$ICON_ERROR" "Unknown argument: $1"; show_help; exit 1 ;; 
  esac
done


# --- 🚀 MAIN LOGIC 🚀 ---

# 1. Prerequisite Checks
print_message "$COLOR_BLUE" "$ICON_INFO" "Checking prerequisites..."
if ! command_exists git; then
  print_message "$COLOR_RED" "$ICON_ERROR" "Git is not installed."
  exit 1
fi
print_message "$COLOR_GREEN" "$ICON_SUCCESS" "Git is installed."

# 2. Git Repository & Remote Setup
if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
  print_message "$COLOR_YELLOW" "$ICON_WARNING" "This is not a git repository."
  if [ "$AUTO_YES" = true ] || prompt_yes_no "Initialize a new repository here?"; then
    git init
    print_message "$COLOR_GREEN" "$ICON_SUCCESS" "Initialized a new git repository."
  else
    print_message "$COLOR_RED" "$ICON_ERROR" "Aborting."
    exit 1
  fi
fi

if ! git remote -v | grep -q '.'; then
    print_message "$COLOR_YELLOW" "$ICON_WARNING" "No remote repository is configured."
    if [ "$AUTO_YES" = true ]; then
        print_message "$COLOR_RED" "$ICON_ERROR" "Cannot proceed without a remote in non-interactive mode."
        exit 1
    fi
    if prompt_yes_no "Add a remote repository now?"; then
        printf "${COLOR_CYAN}%s %s${COLOR_RESET}" "$ICON_QUESTION" "Enter the remote repository URL: "
        read -r remote_url
        if [ -z "$remote_url" ]; then
            print_message "$COLOR_RED" "$ICON_ERROR" "Remote URL cannot be empty. Aborting."
            exit 1
        fi
        git remote add origin "$remote_url"
        print_message "$COLOR_GREEN" "$ICON_SUCCESS" "Remote repository added."
    else
        print_message "$COLOR_YELLOW" "$ICON_WARNING" "Proceeding without a remote. Pushing will not be possible."
    fi
fi

CURRENT_BRANCH=$(git symbolic-ref --short HEAD 2>/dev/null || echo "HEAD (unborn)")
print_message "$COLOR_GREEN" "$ICON_GIT" "Current branch: $CURRENT_BRANCH"

# 3. .gitignore Setup
print_message "$COLOR_BLUE" "$ICON_GIT" "Setting up .gitignore..."
setup_gitignore() {
  local gitignore_patterns=("*.yml" "*.properties")
  if [ ! -f ".gitignore" ]; then
    print_message "$COLOR_YELLOW" "$ICON_WARNING" ".gitignore file not found. Creating one."
    touch .gitignore
  fi
  for pattern in "${gitignore_patterns[@]}"; do
    if ! grep -qF -- "$pattern" .gitignore; then
      print_message "$COLOR_CYAN" "$ICON_INFO" "Adding '$pattern' to .gitignore."
      echo "$pattern" >> .gitignore
    fi
  done
  print_message "$COLOR_GREEN" "$ICON_SUCCESS" ".gitignore is up to date."
}
setup_gitignore

# 4. Versioning
print_message "$COLOR_BLUE" "$ICON_TAG" "Handling versioning..."
get_current_version() {
  if [ -f "pom.xml" ]; then
    # Extract ONLY the <version> directly under <project>, not from <parent>
    local PV=""
    if command_exists xmllint; then
      PV=$(xmllint --xpath 'string(/*[local-name()="project"]/*[local-name()="version"][1])' pom.xml 2>/dev/null || true)
    elif command_exists xmlstarlet; then
      PV=$(xmlstarlet sel -t -v '/*[local-name()="project"]/*[local-name()="version"][1]' pom.xml 2>/dev/null || true)
    else
      # Fallback parser: ignore <parent> block; stop scanning when major sections start
      PV=$(awk '
        BEGIN{in_parent=0; stop=0}
        /<parent[> ]/{in_parent=1}
        in_parent && /<\/parent>/{in_parent=0; next}
        /<dependencies>|<build>|<dependencyManagement>|<profiles>|<modules>|<properties>/{stop=1}
        stop==0 && !in_parent {
          if (match($0, /<version>[[:space:]]*([^<]+)[[:space:]]*<\/[ ]*version>/, m)) { print m[1]; exit }
        }
      ' pom.xml)
    fi
    if [ -n "$PV" ]; then
      echo "$PV"
    elif [ -f "VERSION" ]; then
      cat VERSION
    else
      echo "0.0.0"
    fi
  elif [ -f "VERSION" ]; then
    cat VERSION
  else
    echo "0.0.0"
  fi
}
CURRENT_VERSION=$(get_current_version)
print_message "$COLOR_CYAN" "$ICON_INFO" "Current version: ${CURRENT_VERSION}"

if [ -z "$BUMP_TYPE" ]; then
    if git rev-parse --verify HEAD >/dev/null 2>&1; then
        COMMIT_COUNT=$(git rev-list --count HEAD...$(git describe --tags --abbrev=0 2>/dev/null || git rev-list --max-parents=0 HEAD))
    else
        COMMIT_COUNT=0
    fi
    RECOMMENDATION="patch"
    if [ "$COMMIT_COUNT" -gt 5 ]; then RECOMMENDATION="minor"; fi
    if [ "$COMMIT_COUNT" -gt 20 ]; then RECOMMENDATION="major"; fi
    print_message "$COLOR_YELLOW" "$ICON_INFO" "Recommendation: based on ${COMMIT_COUNT} commits, a '${RECOMMENDATION}' release is suggested."
    printf "${COLOR_CYAN}%s${COLOR_RESET}\n" "Select the version bump:"
    printf "  1) patch\n  2) minor\n  3) major\n  4) keep current\n  5) set specific version\n"
    printf "${COLOR_CYAN}%s %s${COLOR_RESET}" "$ICON_QUESTION" "Enter your choice (1-5): "
    read -r choice
    case $choice in
      1) BUMP_TYPE="patch" ;; 
      2) BUMP_TYPE="minor" ;; 
      3) BUMP_TYPE="major" ;; 
      4) BUMP_TYPE="keep" ;; 
      5) BUMP_TYPE="custom" ;; 
      *) print_message "$COLOR_RED" "$ICON_ERROR" "Invalid choice. Aborting."; exit 1 ;; 
    esac
fi

if [ "$BUMP_TYPE" = "custom" ]; then
  if [ -z "$SET_VERSION" ]; then
    printf "${COLOR_CYAN}%s %s${COLOR_RESET}" "$ICON_QUESTION" "Enter the new version number: "
    read -r SET_VERSION
  fi
  NEW_VERSION=$SET_VERSION
elif [ "$BUMP_TYPE" = "keep" ]; then
  NEW_VERSION=$CURRENT_VERSION
else
  # Normalize current version: strip prerelease/build metadata, ensure numerics
  BASE_VERSION="${CURRENT_VERSION%%-*}"
  MAJOR=$(printf "%s" "$BASE_VERSION" | awk -F. '{print ($1==""?0:$1)+0}')
  MINOR=$(printf "%s" "$BASE_VERSION" | awk -F. '{print ($2==""?0:$2)+0}')
  PATCH=$(printf "%s" "$BASE_VERSION" | awk -F. '{print ($3==""?0:$3)+0}')
  case $BUMP_TYPE in
    "patch") PATCH=$((PATCH + 1)) ;;
    "minor") MINOR=$((MINOR + 1)); PATCH=0 ;;
    "major") MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0 ;;
  esac
  NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
fi
print_message "$COLOR_GREEN" "$ICON_SUCCESS" "Version will be: ${NEW_VERSION}"

if ! [ "$AUTO_YES" = true ] && ! prompt_yes_no "Do you want to proceed?"; then
    print_message "$COLOR_RED" "$ICON_ERROR" "Aborting."; exit 1
fi

if [ "$BUMP_TYPE" != "keep" ]; then
  update_version() {
    local version_to_set=$1
    if [ -f "pom.xml" ]; then
        if ! command_exists mvn; then
            print_message "$COLOR_RED" "$ICON_ERROR" "Maven (mvn) is not installed, but a pom.xml was found. Cannot update version."
            exit 1
        fi
        print_message "$COLOR_CYAN" "$ICON_INFO" "Using Maven to update version in all modules..."
        if ! mvn versions:set -DnewVersion="$version_to_set" -DprocessAllModules=true -DgenerateBackupPoms=false; then
            print_message "$COLOR_RED" "$ICON_ERROR" "Maven versions:set command failed."
            exit 1
        fi
        print_message "$COLOR_GREEN" "$ICON_SUCCESS" "Successfully updated version in all pom.xml files to ${version_to_set}."
    elif [ -f "VERSION" ]; then
      echo "$version_to_set" > VERSION
      print_message "$COLOR_GREEN" "$ICON_SUCCESS" "Updated version in VERSION to ${version_to_set}"
    else
      echo "$version_to_set" > VERSION
      print_message "$COLOR_GREEN" "$ICON_SUCCESS" "Created VERSION file and set version to ${version_to_set}"
    fi
  }
  update_version "$NEW_VERSION"
fi

# 5. Build Project & Update Manifests
print_message "$COLOR_BLUE" "$ICON_BUILD" "Handling build..."
BUILT_JAR_PATH=""
if [ "$NO_BUILD" = true ]; then
    print_message "$COLOR_YELLOW" "$ICON_INFO" "Skipping build step due to --no-build flag."
elif [ -f "pom.xml" ]; then
    if [ "$AUTO_YES" = true ] || prompt_yes_no "Build project with Maven?"; then
        print_message "$COLOR_CYAN" "$ICON_INFO" "Building project with Maven..."
        if ! mvn clean install; then
            print_message "$COLOR_RED" "$ICON_ERROR" "Maven build failed. Aborting."
            exit 1
        fi
        print_message "$COLOR_GREEN" "$ICON_SUCCESS" "Maven build successful."
    else
        print_message "$COLOR_YELLOW" "$ICON_INFO" "Build skipped by user."
    fi
else
  print_message "$COLOR_YELLOW" "$ICON_INFO" "No build file (pom.xml) found. Skipping build step."
fi

update_cf_manifest() {
    local manifest_file=""
    if [ -f "manifest.yml" ]; then manifest_file="manifest.yml"; fi
    if [ -f "manifest.yaml" ]; then manifest_file="manifest.yaml"; fi
    if [ -z "$manifest_file" ]; then return; fi
    
    print_message "$COLOR_BLUE" "$ICON_CF" "Found Cloud Foundry manifest: $manifest_file"
    
    # Find the most relevant JAR file. Prioritize JARs in the same directory as the manifest.
    local manifest_dir
    manifest_dir=$(dirname "$manifest_file")
    local search_path="${manifest_dir}/target"
    
    print_message "$COLOR_CYAN" "$ICON_INFO" "Searching for JAR in '$search_path'..."
    BUILT_JAR_PATH=$(find "$search_path" -name "*.jar" 2>/dev/null | head -n 1)

    if [ -z "$BUILT_JAR_PATH" ]; then
        print_message "$COLOR_YELLOW" "$ICON_WARNING" "No JAR found in '$search_path'. Searching all target directories..."
        BUILT_JAR_PATH=$(find . -path "*/target/*.jar" 2>/dev/null | head -n 1)
    fi

    if [ -z "$BUILT_JAR_PATH" ]; then
        print_message "$COLOR_RED" "$ICON_ERROR" "No built JAR file found. Cannot update manifest."
        return
    fi
    
    print_message "$COLOR_CYAN" "$ICON_INFO" "Found artifact to use: $BUILT_JAR_PATH"

    if ! grep -q "path:" "$manifest_file"; then
        print_message "$COLOR_YELLOW" "$ICON_WARNING" "No 'path' attribute found in $manifest_file. Skipping update."
        return
    fi
    
    print_message "$COLOR_CYAN" "$ICON_INFO" "Attempting to update manifest path..."
    sed -i.bak "s|^\[[:space:]]*path:\).*|\1 ${BUILT_JAR_PATH}|" "$manifest_file" && rm "${manifest_file}.bak"
    
    if [[ $(git status --porcelain "$manifest_file") ]]; then
        print_message "$COLOR_GREEN" "$ICON_SUCCESS" "Successfully modified $manifest_file."
    else
        print_message "$COLOR_RED" "$ICON_ERROR" "Failed to modify $manifest_file. The path may have already been correct."
    fi
}
update_cf_manifest

# 6. Pre-Commit Security Scan & Git Operations
print_message "$COLOR_BLUE" "$ICON_SHIELD" "Performing security scan and Git operations..."
scan_for_secrets() {
  print_message "$COLOR_CYAN" "$ICON_INFO" "Scanning for potential hardcoded secrets in staged files..."
  local staged_files
  staged_files=$(git diff --cached --name-only --diff-filter=AM)
  if [ -z "$staged_files" ]; then
      print_message "$COLOR_GREEN" "$ICON_SUCCESS" "No new or modified files to scan."
      return 0
  fi
  local keyword_pattern='(password|secret|token|apikey|private_key)'
  local safe_assignment_pattern='(=\s*(\$|\{\{<%|env\(|<))|:\s*(\$|\{\{|<))'
  local all_findings=""
  for file in $staged_files; do
    if ! [[ $(file -b --mime-type "$file") == text/* ]]; then continue; fi
    if [[ $(basename "$file") == "dbbuild" ]]; then continue; fi
    local suspicious_lines
    suspicious_lines=$(grep -iEn "$keyword_pattern\s*[:=]" "$file" | grep -viE "$safe_assignment_pattern")
    if [ -n "$suspicious_lines" ]; then
      all_findings+="\n--- Findings in ${COLOR_CYAN}${file}${COLOR_RESET} ---\n"
      all_findings+=$(echo "$suspicious_lines" | grep -iE --color=always "$keyword_pattern")
    fi
  done
  if [ -n "$all_findings" ]; then
    print_message "$COLOR_RED" "$ICON_ERROR" "POTENTIAL HARDCODED SECRETS FOUND!"
    print_message "$COLOR_YELLOW" "$ICON_WARNING" "Found lines that appear to set a secret to a specific value."
    printf "%b\n" "$all_findings"
    printf "\n"
    if ! [ "$AUTO_YES" = true ] && ! prompt_yes_no "Are you sure you want to commit these files?"; then
      print_message "$COLOR_RED" "$ICON_ERROR" "Commit aborted by user. Please remove secrets from your files."
      exit 1
    fi
  else
    print_message "$COLOR_GREEN" "$ICON_SUCCESS" "No potential hardcoded secrets found."
  fi
}

git add .
scan_for_secrets

COMMIT_MSG="chore(release): version ${NEW_VERSION}"
COMMIT_ARGS=("-m" "$COMMIT_MSG")
if [ "$BUMP_TYPE" = "keep" ]; then
  COMMIT_MSG="chore(release): trigger build for version ${NEW_VERSION}"
  COMMIT_ARGS=("--allow-empty" "-m" "$COMMIT_MSG")
fi
git commit "${COMMIT_ARGS[@]}"

TAG_NAME="v${NEW_VERSION}"
if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
    print_message "$COLOR_YELLOW" "$ICON_WARNING" "Tag '$TAG_NAME' already exists."
    if [ "$AUTO_YES" = true ] || prompt_yes_no "Do you want to overwrite it? (This is not recommended)"; then
        print_message "$COLOR_CYAN" "$ICON_INFO" "Overwriting tag '$TAG_NAME'..."
        git tag -d "$TAG_NAME"
        git push --delete origin "$TAG_NAME"
    else
        print_message "$COLOR_RED" "$ICON_ERROR" "Aborting. Tag not overwritten."
        exit 1
    fi
fi
git tag -a "$TAG_NAME" -m "Version ${NEW_VERSION}"
print_message "$COLOR_GREEN" "$ICON_SUCCESS" "Committed and tagged release."

print_message "$COLOR_CYAN" "$ICON_INFO" "Pushing to remote..."
if git push && git push --tags; then
  print_message "$COLOR_GREEN" "$ICON_SUCCESS" "Successfully pushed to remote."
else
  print_message "$COLOR_RED" "$ICON_ERROR" "Failed to push to remote. Aborting."
  exit 1
fi

# 7. GitHub Integration
print_message "$COLOR_BLUE" "$ICON_RELEASE" "Handling GitHub operations..."
if ! command_exists gh; then
    print_message "$COLOR_YELLOW" "$ICON_WARNING" "gh (GitHub CLI) not found. Skipping GitHub integration."
else
    if ! gh auth status > /dev/null 2>&1; then
        print_message "$COLOR_YELLOW" "$ICON_WARNING" "Not logged into GitHub CLI."
        if ! [ "$AUTO_YES" = true ] && prompt_yes_no "Authenticate with GitHub now?"; then
           gh auth login
        fi
    fi
    if gh auth status > /dev/null 2>&1; then
        if [ "$AUTO_YES" = true ] || prompt_yes_no "Create a pull request?"; then
            print_message "$COLOR_CYAN" "$ICON_PULL_REQUEST" "Creating pull request..."
            gh pr create --fill --web
        fi
        if [ "$AUTO_YES" = true ] || prompt_yes_no "Create a GitHub release?"; then
            print_message "$COLOR_CYAN" "$ICON_RELEASE" "Creating GitHub release..."
            RELEASE_ARGS=("$TAG_NAME" --title "Release ${NEW_VERSION}" --notes "Release version ${NEW_VERSION}")
            if [ "$NO_JAR" = false ]; then
                # Re-find the JAR path in case the build was skipped earlier but a JAR exists.
                if [ -z "$BUILT_JAR_PATH" ]; then
                    BUILT_JAR_PATH=$(find . -path "*/target/*.jar" 2>/dev/null | head -n 1)
                fi
                if [ -n "$BUILT_JAR_PATH" ]; then
                    RELEASE_ARGS+=("$BUILT_JAR_PATH")
                    print_message "$COLOR_GREEN" "$ICON_SUCCESS" "Found JAR file to attach: $BUILT_JAR_PATH"
                else
                    print_message "$COLOR_YELLOW" "$ICON_WARNING" "No JAR file found to attach."
                fi
            else
                print_message "$COLOR_YELLOW" "$ICON_INFO" "Skipping JAR attachment due to --no-jar flag."
            fi
            if gh release create "${RELEASE_ARGS[@]}"; then
                print_message "$COLOR_GREEN" "$ICON_SUCCESS" "Successfully created GitHub release."
            else
                print_message "$COLOR_RED" "$ICON_ERROR" "Failed to create GitHub release."
            fi
        fi
    fi
fi

print_message "$COLOR_GREEN" "$ICON_ROCKET" "dbbuild finished successfully!"
